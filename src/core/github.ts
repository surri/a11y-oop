import { Octokit } from '@octokit/rest'
import type { GitHubRepoConfig, FixPatch, GitHubPrResult } from '@/shared/types'

export function createOctokit(token: string): Octokit {
  return new Octokit({ auth: token })
}

export async function readRepoFiles(
  octokit: Octokit,
  config: GitHubRepoConfig
): Promise<Record<string, string>> {
  const filePattern = config.filePattern ?? '**/*.tsx'

  const { data: refData } = await octokit.git.getRef({
    owner: config.owner,
    repo: config.repo,
    ref: `heads/${config.branch}`,
  })
  const commitSha = refData.object.sha

  const { data: commitData } = await octokit.git.getCommit({
    owner: config.owner,
    repo: config.repo,
    commit_sha: commitSha,
  })
  const treeSha = commitData.tree.sha

  const { data: treeData } = await octokit.git.getTree({
    owner: config.owner,
    repo: config.repo,
    tree_sha: treeSha,
    recursive: '1',
  })

  const extMatch = filePattern.match(/\*\.(\w+)$/)
  const allowedExt = extMatch ? `.${extMatch[1]}` : '.tsx'

  const srcPrefix = config.srcPath.endsWith('/') ? config.srcPath : `${config.srcPath}/`

  const relevantFiles = (treeData.tree ?? []).filter(
    (item) =>
      item.type === 'blob' &&
      item.path !== undefined &&
      item.path.startsWith(srcPrefix) &&
      item.path.endsWith(allowedExt)
  )

  const results: Record<string, string> = {}

  await Promise.all(
    relevantFiles.map(async (item) => {
      if (!item.sha || !item.path) return
      const { data: blobData } = await octokit.git.getBlob({
        owner: config.owner,
        repo: config.repo,
        file_sha: item.sha,
      })
      const content =
        blobData.encoding === 'base64'
          ? Buffer.from(blobData.content, 'base64').toString('utf-8')
          : blobData.content
      const relativePath = item.path.slice(srcPrefix.length)
      results[relativePath] = content
    })
  )

  return results
}

export async function createFixPR(
  octokit: Octokit,
  config: GitHubRepoConfig,
  patches: FixPatch[]
): Promise<GitHubPrResult> {
  const { data: refData } = await octokit.git.getRef({
    owner: config.owner,
    repo: config.repo,
    ref: `heads/${config.branch}`,
  })
  const baseSha = refData.object.sha

  const { data: baseCommit } = await octokit.git.getCommit({
    owner: config.owner,
    repo: config.repo,
    commit_sha: baseSha,
  })
  const baseTreeSha = baseCommit.tree.sha

  const branchName = `a11y-fix/${Date.now()}`
  await octokit.git.createRef({
    owner: config.owner,
    repo: config.repo,
    ref: `refs/heads/${branchName}`,
    sha: baseSha,
  })

  const srcPrefix = config.srcPath.endsWith('/') ? config.srcPath : `${config.srcPath}/`

  const treeUpdates: Array<{
    path: string
    mode: '100644'
    type: 'blob'
    sha: string
  }> = []

  await Promise.all(
    patches.map(async (patch) => {
      const filePath = patch.filePath.startsWith(srcPrefix)
        ? patch.filePath
        : `${srcPrefix}${patch.filePath}`

      const { data: fileData } = await octokit.repos.getContent({
        owner: config.owner,
        repo: config.repo,
        path: filePath,
        ref: config.branch,
      })

      const fileContent = Array.isArray(fileData) ? null : fileData
      if (!fileContent || fileContent.type !== 'file' || !('content' in fileContent)) return

      const currentContent = Buffer.from(fileContent.content as string, 'base64').toString('utf-8')
      const updatedContent = currentContent.replace(patch.original, patch.replacement)

      const { data: newBlob } = await octokit.git.createBlob({
        owner: config.owner,
        repo: config.repo,
        content: updatedContent,
        encoding: 'utf-8',
      })

      treeUpdates.push({
        path: filePath,
        mode: '100644',
        type: 'blob',
        sha: newBlob.sha,
      })
    })
  )

  const { data: newTree } = await octokit.git.createTree({
    owner: config.owner,
    repo: config.repo,
    base_tree: baseTreeSha,
    tree: treeUpdates,
  })

  const { data: newCommit } = await octokit.git.createCommit({
    owner: config.owner,
    repo: config.repo,
    message: 'fix: apply automated accessibility fixes\n\nGenerated by A11y Oop',
    tree: newTree.sha,
    parents: [baseSha],
  })

  await octokit.git.updateRef({
    owner: config.owner,
    repo: config.repo,
    ref: `heads/${branchName}`,
    sha: newCommit.sha,
  })

  const { data: pr } = await octokit.pulls.create({
    owner: config.owner,
    repo: config.repo,
    title: `fix: automated accessibility fixes (${patches.length} issue${patches.length !== 1 ? 's' : ''})`,
    body: `## Automated Accessibility Fixes\n\nThis PR was generated by [A11y Oop](https://github.com/a11y-oop).\n\n### Changes\n- Fixed ${patches.length} accessibility issue${patches.length !== 1 ? 's' : ''} detected by automated scanning\n- Patches applied to ${treeUpdates.length} file${treeUpdates.length !== 1 ? 's' : ''}`,
    head: branchName,
    base: config.branch,
  })

  return {
    prUrl: pr.html_url,
    prNumber: pr.number,
    branchName,
    filesChanged: treeUpdates.length,
  }
}

export async function validateRepoAccess(
  octokit: Octokit,
  owner: string,
  repo: string
): Promise<{ valid: boolean; defaultBranch: string }> {
  try {
    const { data } = await octokit.repos.get({ owner, repo })
    return { valid: true, defaultBranch: data.default_branch }
  } catch {
    return { valid: false, defaultBranch: 'main' }
  }
}
